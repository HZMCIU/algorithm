#### 基础背景

1. **&**:按位与运算 按位与运算符"&"是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1 ，否则为0
2. **|:** 按位或运算 按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1
3. **^:** 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1
4. **~:**对参与运算的数的各二进位按位求反
5. **\>>:** 把“<< ”左边的运算数的各二进位全部左移若干位，由“<<”右边的数指定移动的位数，高位丢弃，低位补0
6. **<<:** 把“>> ”左边的运算数的各二进位全部右移若干位，“>>”右边的数指定移动的位数

#### ACM应用

1. **清零**

   若想对一个存储单元清零，即使其全部二进制位为0，只要找一个二进制数，其中各个位符合一下条件：原来的数中为1的位，新数中相应位为0。然后使二者进行&运算，即可达到清零目的

   例：原数为43，即00101011（2），另找一个数，设它为148，即10010100（2），将两者按位与运算：

      00101011（2）

   &10010100（2）

      00000000（2）

2. **取一个数中某些指定位**

   若有一个整数a(2 byte),想要取其中的低字节，只需要将a与8个1按位与即可。

   a 00101100 10101100

   b 00000000 11111111

   c 00000000 10101100

3. **保留指定位**

   与一个数进行“按位与”运算，此数在该位取1.

   例如：有一数84，即01010100（2），想把其中从左边算起的第3，4，5，7，8位保留下来，运算如下：

      01010100(2)

   &00111011(2)

      00010000(2)

4. **按位或运算常用来对一个数据的某些位定值为1**

   例如：如果想使一个数a的低4位改为1，则只需要将a与17（8）进行按位或运算即可

5. **使特定位翻转**

   设有数01111010（2），想使其低4位翻转，即1变0，0变1.可以将其与00001111（2）进行“异或”运算，

   即：
     01111010
   ^00001111
     01110101
   运算结果的低４位正好是原数低４位的翻转。可见，要使哪几位翻转就将与其进行∧运算的该几位置为１

   即可。

6. **与0相“异或”，保留原值**

   例如：012^00=012

​         00001010

​       ^00000000

​         00001010

​	因为原数中的1与0进行异或运算得1，0^0得0，故保留原数。

7. **交换两个值，不用临时变量**

   例如：ａ＝３，即11（2）；ｂ＝４，即100（2）。
   想将ａ和ｂ的值互换，可以用以下赋值语句实现：
   ​    ａ＝a∧b;
   ​    ｂ＝b∧a;
   ​    ａ＝a∧b;
   ａ＝011(2)
   ​    （∧）ｂ＝100(2)
   ａ＝111(2)（a∧b的结果，a已变成７）
   ​    （∧）ｂ＝100(2)
   ｂ＝011(2)（b∧a的结果，b已变成３）
   ​    （∧）ａ＝111(2)

   ａ＝100（2）（a∧b的结果，a已变成４）
   等效于以下两步：
   ​    ① 执行前两个赋值语句：“ａ＝ａ∧ｂ；”和“ｂ＝ｂ∧ａ；”相当于b=b∧(a∧b)。
   ​    ② 再执行第三个赋值语句： ａ＝ａ∧ｂ。由于a的值等于（ａ∧ｂ），b的值等于（ｂ∧ａ∧ｂ），

   因此，相当于a=ａ∧ｂ∧ｂ∧ａ∧ｂ，即a的值等于ａ∧ａ∧ｂ∧ｂ∧ｂ，等于ｂ。

8. **判断奇偶** 

   `a&1   = 0 偶数`

   `a&1 =   1 奇数`

9. **取int型变量a的第k位** (k=0,1,2……sizeof(int))，即`a>>k&1`

10. **将int型变量a的第k位清0**，即`a=a&~(1<<k)`

11. **将int型变量a的第k位置1**，即`a=a|(1<<k)`

12. **int型变量循环左移k次**，即`a=a<<k|a>>16-k `  (设sizeof(int)=16)

13. **int型变量a循环右移k次**，即`a=a>>k|a<<16-k`   (设sizeof(int)=16)

14. **整数的平均值** 

    对于两个整数x,y，如果用 (x+y)/2 求平均值，会产生溢出，因为 x+y 可能会大于INT_MAX，但是我们知道它们的平均值是肯定不会溢出的，我们用如下算法：

    ```cpp
    int average(int x, int y)   //返回X,Y 的平均值
    {   
        return (x&y)+((x^y)>>1);
    }

    ```

    ​

15. **判断一个整数是不是2的幂**

    ```cpp
    boolean power2(int x)
    {
    	return ((x&(x-1))==0)&&(x!=0)；
    }

    ```

    ​

16. **不用temp交换两个整数**

    ```cpp
    void swap(int x , int y)
    {
        x ^= y;
        y ^= x;
        x ^= y;
    }

    ```

    ​

17. **计算绝对值**

    ```cpp
    int abs( int x )
    {
    	int y ;
    	y = x >> 31 ;
    	return (x^y)-y ;        //or: (x+y)^y
    }

    ```

18. **取模运算转化成位运算** (在不产生溢出的情况下)

    ​         `a % (2^n) `等价于` a & (2^n - 1)`

19. **乘法运算转化成位运算** (在不产生溢出的情况下)

    ​        `a * (2^n) `等价于` a<< n`

20. **除法运算转化成位运算** (在不产生溢出的情况下)

    ​         `a / (2^n)` 等价于 `a>> n`

21. `a % 2 `等价于 `a & 1`

22. ```cpp
    if (x == a) x= b;
    else x= a; //等价于 x= a ^ b ^ x;
    ```

23. x 的 相反数 表示为` (~x+1)`

24. ​
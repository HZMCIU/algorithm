# SG函数和SG定理

(https://www.cnblogs.com/ECJTUACM-873284962/p/6921829.html)

https://www.cnblogs.com/hsqdboke/archive/2012/04/21/2461034.html

1. **概念和性质：** 

   + **P点**：必败点，换而言之，就是谁处于此位置，则在双方操作正确的情况下必败。(Previous player win)

   + **N点**：必胜点，处于此情况下，双方操作均正确的情况下必胜。必胜点和必败点的性质(Next player win)

     **性质**

   + 所有终结点是 必败点 P 。（我们以此为基本前提进行推理，换句话说，我们以此为假设）

   + 从任何必胜点N 操作，至少有一种方式可以进入必败点 P。

   + 无论如何操作，必败点P 都只能进入 必胜点 N。

     > 一个点v是P-状态当且仅当它的所有后继都为N-状态

     >  一个点v是N-状态当且仅当它的一些后继是P-状态

   + **游戏的P-和N-状态的信息提供了它的必胜策略。如果轮到我们且游戏处在一个N-状态，我们应该转移到一个P-状态（对手的状态）。接着我们的对手就会被迫进入N-状态（自己的状态），依此类推。我们最终会移入一个汇点并获得胜利。**

2. **游戏的和：**

   1. **定义：**如果G1和G2 是公平游戏，那么他们的和G1 + G2是另一个公平游戏

   2. **玩法：**每个回合，一个玩家选择G1, G2 中的一个（随便哪个他希望的）然后玩它，不碰另一个游戏。当 G1 和 G2都不能操作时游戏结束

   3. **数学表示：**

      形式上，如果 $G1 = (V1, E1) 和 G2 = (V2, E2)$是游戏图，那么他们的和$ Gsum = (Vsum, Esum) $规定为：

      $Vsum = V1 × V2,$

      $Esum = {(v1v2, w1v2) | (v1, w1) ∈ E1} ∪ {(v1v2, v1w2) | (v2, w2) ∈ E2}$.

   4. **SG函数的定理的引入：**

      现在，假定我们给出两个游戏G1 和 G2。如果我们只知道单个游戏的P-状态和N-状态我们能够正确地玩好游戏和G1 + G2吗？答案是否定的。**不难看出两个P-状态的和总是P-状态，P-状态和N-状态的和总是N-状态。但是两个N-状态的和既可能是P-状态也可能是N-状态。因此，只知道单个游戏的P-状态和N-状态是不够的。**为了正确地玩好游戏和我们需要推广P-状态和N-状态，它就是Sprague-Grudy函数（或者简称为Grundy函数）

3. **Sprague-Grundy定理（SG定理）:**

   **游戏和的SG函数等于各个游戏SG函数的Nim和** 。这样就可以将每一个子游戏分而治之，从而简化了问题。而Bouton定理就是Sprague-Grundy定理在Nim游戏中的直接应用，因为单堆的Nim游戏 SG函数满足 SG(x) = x。

4. **SG函数：** 

   + **mex(minimal excludant)运算:** 

     这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如$mex\{0,1,2,4\}=3、mex\{2,3,5\}=0、mex\{\}=0$

   + **定义：** 对于任意状态 x ， 定义 $SG(x) = mex(S)$,其中 S 是 x 后继状态的SG函数值的集合。如 x 有三个后继状态分别为$ SG(a),SG(b),SG(c)，那么SG(x) = mex\{SG(a),SG(b),SG(c)\}$。 这样 集合S 的终态必然是空集，所以SG函数的终态为 **SG(x) = 0,当且仅当 x 为必败点P时**。

   + **性质：**

     1. **点v是一个P-状态当且仅当SG(v)=0** 


     2. **如果G = G1 + G2 且 v = v1v2 是G的一个状态，那么g(v) 为g(v1) 和 g(v2) 在二进制下的异或：**

     **SG(v) = SG(v1) ⊕ SG(v2).** **运算⊕也称作nim和**。举个例子，3 ⊕ 5 = 011 ⊕ 101 = 110 = 6。类似地，3 ⊕ 6 = 5 且 5 ⊕ 6 = 3。

5. **例子**

   有1堆n个的石子，每次只能取{ 1, 3, 4 }个石子，先取完石子者胜利，那么各个数的SG值为多少？

   SG[0]=0，f[]={1,3,4},

   x=1 时，可以取走1 - f{1}个石子，剩余{0}个，所以 SG[1] = mex{ SG[0] }= mex{0} = 1;

   x=2 时，可以取走2 - f{1}个石子，剩余{1}个，所以 SG[2] = mex{ SG[1] }= mex{1} = 0;

   x=3 时，可以取走3 - f{1,3}个石子，剩余{2,0}个，所以 SG[3] = mex{SG[2],SG[0]} = mex{0,0} =1;

   x=4 时，可以取走4-  f{1,3,4}个石子，剩余{3,1,0}个，所以 SG[4] = mex{SG[3],SG[1],SG[0]} = mex{1,1,0} = 2;

   x=5 时，可以取走5 - f{1,3,4}个石子，剩余{4,2,1}个，所以SG[5] = mex{SG[4],SG[2],SG[1]} =mex{2,0,1} = 3;

   以此类推.....

      x        0  1  2  3  4  5  6  7  8....

   SG[x]    0  1  0  1  2  3  2  0  1....

6. **SG函数的求解步骤：**

   + 使用 数组f 将 可改变当前状态 的方式记录下来。（**f：当前可以取得小球的个数**）
   + 然后我们使用 另一个数组将当前状态x 的后继状态标记。
   + 最后模拟mex运算，也就是我们**在标记值中 搜索 未被标记值 的最小值**，将其赋值给SG(x)。
   + 我们不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。

7. **代码：**

   ```cpp
   //f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理
   //SG[]:0~n的SG函数值
   //S[]:为x后继状态的集合
   int f[N],SG[MAXN],S[MAXN];
   void  getSG(int n){
       int i,j;
       memset(SG,0,sizeof(SG));
       //因为SG[0]始终等于0，所以i从1开始
       for(i = 1; i <= n; i++){
           //每一次都要将上一状态 的 后继集合 重置
           memset(S,0,sizeof(S));
           for(j = 0; f[j] <= i && j <= N; j++)
               S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记
           for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值
               SG[i] = j;
               break;
           }
       }
   }
   ```

   ​

8. **Nim游戏**

   ​	最基本的公平游戏是Nim堆。一个Nim堆由确定数目代币组成。在每个回合，一个玩家从堆上拿走1到整堆中任意数目的代币。拿空整堆的人获得胜利。这个游戏如果独立看是没有意义的：先手玩家可直接拿走所有代币并立即获得胜利！ **但是如果我们将各种大小的Nim堆加在一起，我们就得到了著名的Nim游戏**。大小为n的Nim堆的Grundy值为n。因此，Nim游戏中每个状态的Grundy值为每堆大小的Nim和。

9. **一些分解成自身和的游戏**

   **Sprague-Grundy定理最自然的应用就是一些分解成自身和的一些游戏。**

   考虑下面这个游戏：有一个大小为m*n的棋盘，且有无限数目某特定形状的骨牌供应。在每个回合，玩家在棋盘上一个空位放置一个骨牌，不能放骨牌的玩家就是败者。 

   在游戏期间，棋盘会逐渐分成不同的区域，对其我们可以分别计算Grundy值。

   ​	

   再举个例子，考虑Grundy游戏。这个游戏的一个状态由一些不同大小的代币堆组成，**一次操作由只取一堆并把它分成两个不相等的堆组成。**当所有堆的大小只有1和2的时候游戏结束，因为它不能再分。

   令g(n)为单个大小为n的堆的Grundy值。数列g(n)如下：

   **n**:     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20...

   **g(n)**:0  0  1  0  2  1  0  2  1  0   2   1  3   2   1   3  2   4   3  0

   比如：

   当n等于1,2时已满足条件,即不能再取，也就没有下一个局面,所以g(1)={};所以G(1)={0,1,2,3,4...};

   所以g(1)=0;同理g(2)=0;依次递推,g(3),g(4),g(5)等，

   例如：g(6)={#(1,5),#(2,4)}={g(1)+g(5),g(2)+g(4)}=g(2,0);

   所以G(6)={1,3,4,5,6...},所以g(6)=1;

